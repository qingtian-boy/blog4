---
title: 微信小程序02
date: 2019-01-26 18:56:26
tags: 小程序
---
# 目录
# 二、知识路径

- 事件的使用方式
- 事件分类
- 事件绑定
- 事件对象

==目标：能够掌握事件的绑定和使用==

- 基础组件
- view组件

==目标：能够根据事件和view组件实现点击按钮切换内容==

- swiper滑块

==目标：能够掌握使用滑块(轮播图)==

- scroll-view

==目标：能够掌握使用scroll-view加载更多内容==

- 基础内容组件
- 按钮

==目标：能够掌握按钮的使用==

input组件

form组件

==目标：能够创建form表单模拟登陆功能==

# 三、 今日课程内容
<!-- more -->

## 1、事件的使用方式

​	直接在组件中绑定一个事件处理函数，如果是非自定义模板，则使用 bindtap 或 bind:tap，如果是自定义的，则使用bind:tap。

==注意：无论是自定义还是非自定义，都推荐使用 bind:tap方式==

**示例：**展示为标签绑定点击事件

1.新创建一个小程序页面

![1548245525505](1548245525505.png)

2.在 tap 页面中 tap.wxml 文件中构建如下标签代码，并且为该标签绑定一个点击事件

![1548245646088](1548245646088.png)

3.接着需要在页面的 tap.js 文件中创建出相应的处理函数，代码如下

![1548245798461](1548245798461.png)

4.测试使用效果

![1548245842006](1548245842006.png)

## 2、事件分类

小程序中事件分为冒泡和非冒泡

冒泡事件( ==bind== )：当一个节点事件被触发后，该事件会向父节点传弟。

非冒泡事件( ==catch== )：当一个节点事件被触发后，该事件不会向父节点传递。

wxml 的公共事件类型：

| 类型               | 触发条件                                                     | 最低版本 |
| ------------------ | ------------------------------------------------------------ | -------- |
| touchstart         | 手指触摸动作开始                                             |          |
| touchmove          | 手指触摸后移动                                               |          |
| touchcancel        | 手指触摸动作被打断，如来电提醒，弹窗                         |          |
| touchend           | 手指触摸动作结束                                             |          |
| ==tap==            | 手指触摸后马上离开点击                                       |          |
| longpress          | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 | 1.5.0    |
| longtap            | 手指触摸后，超过 350ms 再离开(推荐使用 longpress事件代替)    |          |
| transitionend      | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发    |          |
| animationstart     | 会在一个 WXSS animation 动画开始时触发                       |          |
| animationiteration | 会在一个 WXSS animation 一次迭代结束时触发                   |          |
| animationend       | 会在一个 WXSS animation 动画完成时触发                       |          |
| touchforcechange   | 在支持 3D Touch 的 iPhone 设备，重按时会触发                 | 1.9.90   |

**案例：**测试冒泡事件

1.创建一个新的页面

![1548246501065](1548246501065.png)

2.然后在 mp.wxml 中构建如下内容

![1548246654933](1548246654933.png)

3.再接着在 mp.js 中创建两相应的绑定函数

![1548246846022](1548246846022.png)

4.最后测试结果

![1548246921267](1548246921267.png)

上面的效果说明是冒泡了。

**案例：**测试非冒泡事件

1.直接在 mp.wxml 中复制一段冒泡绑定事件的标签，将子标签修改成 catch 形式

![1548247099891](1548247099891.png)

2.测试结果如下

![1548247157519](1548247157519.png)

只输出了 son 的内容，说明非冒泡。

## 3、事件绑定

绑定的方式：

```html
key:type="value"
```

1.key的值为 bind 或 catch

2.type即事件类型

3.value是一个字符串，绑定时 value 是什么字符串，则相应的必须要在当前页面的 js 文件中定义同名的函数

例如：

```html
<ivew bind:tap="func1">...</ivew>
```

**案例1：**实现长按 3秒输出 “100分”，长按其他时间则输出 ”请继续努力“

1.首先创建 longpress目录

![1548247772710](1548247772710.png)

2.然后在 longpress.wxml 中构建如下代码，为 view 标签绑定两个事件

![1548247932838](1548247932838.png)

3.然后在 longpress.js 中创建相应的函数，如下图所示

![1548248392544](1548248392544.png)

4.测试结果如下

![1548248523608](1548248523608.png)

## 4、事件对象

如无特殊说明，当节点触发事件时，绑定该事件的处理函数会收到一个事件对象。

BaseEvent 基础事件对象属性列表：

| 属性              | 类型    | 说明                                                 |
| ----------------- | ------- | ---------------------------------------------------- |
| type              | String  | 事件类型                                             |
| timeStamp         | Integer | 事件生成时的时间戳                                   |
| target            | Object  | 触发事件的组件的一些属性值集合                       |
| ==currentTarget== | Object  | 当前组件的一些属性值集合在组件中 ==data-==定义的属性 |

==注意：事件对象最大的作用在于给触发执行的函数传递参数。而参数需要在标签中通过“data-参数名=参数值”的方式来指定。==

**案例：**给一个绑定点击事件触发执行的函数，传递参数`id=100`，`name=张三`和`age=12`参数数据；并且让传递给函数的参数回显到视图的 view 容器中。

1.首先创建一个新页面

![1548251673850](1548251673850.png)

2.然后在 evtobj.wxml 中构建代码如下

![1548252367510](1548252367510.png)

3.再接着在 evtobj.js 中创建相应的数据和函数，来处理点击事件的效果

![1548252410551](1548252410551.png)

4.结果如下图所示

![1548252437169](1548252437169.png)

## 5、基础组件

==注意：这里的基础组件通俗的讲就是标签。==

什么是组件：

- 组件是视图层的基本组成单元
- 组件自带了一些功能和微信风格的样式
- 一个组件通常包括==开始标签==和==结束标签==，==属性==用来修饰这个组件，==内容==在两个标签当中

基本格式为：

```html
<tagname property="value">
	....
</tagname>
```

### 5.1、组件属性值类型和共同属性

组件属性值类型有：

![1548253436550](1548253436550.png)

组件的共同属性：

![1548253483346](1548253483346.png)

## 6、view 组件

view 也被称为视图容器。相当于 html 中的 div 标签。

官方开发文档：https://developers.weixin.qq.com/miniprogram/dev/component/view.html

![1548253580961](1548253580961.png)

**案例：**实现 tab 切换栏，效果如下图，点击“显示内容1”则“内容1111111”展示；点击“显示内容2”则“内容2222222”展示，而“内容1111111”隐藏。

![1548253893131](1548253893131.png)

样式说明：

```css
display:flex; #弹性盒子
justify-content: space-around;	#弹性盒子四周留空白
border: 尺寸 样式 颜色; #对边线设置
```

**实现：**

1.首先创建一个新页面

![1548254052998](1548254052998.png)

2.然后在 view.wxml 中构建如下图所示的代码

![1548254824360](1548254824360.png)

3.然后在 view.wxss 中定义样式

![1548254512946](1548254512946.png)

4.再接着在 view.js 中定义方法与变量

![1548255091272](1548255091272.png)

5.测试结果如下图所示

![1548255111897](1548255111897.png)

点击不同按钮会显示不同内容。

## 7、swiper 滑块

==需求：使用 swiper 滑块实现轮播图。==

1.新建一个页面

![1548470330497](1548470330497.png)

2.然后在 swiper.wxml 文件中构建代码

![1548471133988](1548471133988.png)

3.然后在 swiper.js 文件中构建代码

![1548471208880](1548471208880.png)

4.然后在 swiper.wmss 文件中构建代码

![1548471243085](1548471243085.png)

5.效果如下图所示

![1548471280013](1548471280013.png)

## 8、scroll-view

基础结构：

```html
<scroll-view>
	<view>内容1</view>
    <view>内容2</view>
    ...
    <view>内容n</view>
</scroll-view>
```

==需求：使用 scroll-view 上(下)拉加载内容。==

==**实现：**==

1.首先新建一个页面

![1548327960230](1548327960230.png)

2.然后在 sview.wxml 中创建如下代码

![1548329479836](1548329479836.png)

3.接着在 sview.js 文件

![1548330926963](1548330926963.png)

![1548330954511](1548330954511.png)

4.效果如下图所示

![1548330992624](1548330992624.png)

## 9、基础内容组件

### 9.1、图标icon

基本结构：

```html
<view>
	<icon type="type值" size="尺寸大小" />
</view>
```

![1548331843904](1548331843904.png)

**案例：**

1.首先新建一个页面

![1548332039511](1548332039511.png)

2.然后在 icon.wxml 构建代码

![1548332254014](1548332254014.png)

3.测试效果如下图所示

![1548332273270](1548332273270.png)

### 9.2、文本text

基本结构：

```html
<view>
	<text>文件内容</text>
</view>
```

![1548332313631](1548332313631.png)

1.首先新建一个页面

![1548332415669](1548332415669.png)

2.然后在 text.wxml 文件中构建代码

![1548332671627](1548332671627.png)

3.测试效果如下图所示

![1548332692187](1548332692187.png)

## 10、按键

官方开发文档：https://developers.weixin.qq.com/miniprogram/dev/component/button.html

1.首先新建一个页面

![1548332905451](1548332905451.png)

2.然后在 btn.wxml 文件中构建代码

![1548333100104](1548333100104.png)

3.测试效果如下图所示

![1548333121280](1548333121280.png)

==**需求1：**==实现分享按钮

拓展内容：onShareAppMessage 返回值支持的事件回调函数：success、fail、complete

==**实现：**==

1.首先在 btn.wxml 中构建代码如下

![1548333451885](1548333451885.png)

2.然后在 btn.js 中构建代码如下

![1548485348580](1548485348580.png)

==注意：该方法默认已经存在==

3.测试效果如下图所示

![1548334211615](1548334211615.png)

==**需求2：**==实现客服按钮

==**实现：**==

1.首先在 btn.wxml 文件中构建代码

![1548335854204](1548335854204.png)

> ==注意：==
>
> ​	登陆在线上客服后台地址如下：
>
> ​	https://mpkf.weixin.qq.com
>
> ![1548486468261](1548486468261.png)
>
> ​	==不能在模拟器中调用==
>
> ​	==需要先添加客户人员==
>
> ![1548486384571](1548486384571.png)
>
> ​	==创建项目时的appid一定要与自己申请的那个小程序的appid一样==
>
> ![1548486355203](1548486355203.png)

## 11、input组件

官方开发文档：https://developers.weixin.qq.com/miniprogram/dev/component/input.html

**示例：**常用属性测试

1.首先新建一个页面

![1548336187926](1548336187926.png)

2.然后 input.wxml 中构建代码如下

![1548336313100](1548336313100.png)

3.在 input.wxss 中定义样式

![1548336368663](1548336368663.png)

4.测试结果如下

![1548336383573](1548336383573.png)

==**需求：**==输入内容的同时，在模板中立即回显输入的内容

==**实现：**==

1.在 input.wxml 中构建代码

![1548336750371](1548336750371.png)

2.在 input.js 中定义方法与变量

![1548337182206](1548337182206.png)

3.测试结果如下

![1548337222662](1548337222662.png)

## 12、form组件

其核心作用就是和 input 组件形成 form 表单。

官方开发文档：https://developers.weixin.qq.com/miniprogram/dev/component/form.html

==**需求：**==构建登陆界面 form 表单，模拟实现登陆验证

==**实现：**==

1.首先新建一个新的页面

![1548337945549](1548337945549.png)

2.然后在 form.wxml 中构建代码

![1548338876408](1548338876408.png)

3.然后在 form.wxss 中定义样式

![1548338644124](1548338644124.png)

4.再在 form.js 中定义方法，并接收

![1548339018663](1548339018663.png)

5.测试结果如下图所示

![1548339058376](1548339058376.png)

## 13、导航组件navigator

官方开发文档：https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html

注意：在其众多的属性中，最具价值的就==open-type==属性。

**示例1：**构建可回退导航

1.在 form.wxml 中构建代码

![1548489311691](1548489311691.png)

2.效果如下图所示

![1548489331075](1548489331075.png)

3.点击后的效果

![1548489354042](1548489354042.png)

**示例2：**构建不可回退导航

1.在 form.wxml 中构建代码

![1548489472990](1548489472990.png)

2.效果如下图所示

![1548489492451](1548489492451.png)

3.测试结果如下图所示

![1548489510506](1548489510506.png)

**示例3：**通过点击事件实现跳转到某个指定的页面并携带参数id=1和name=php33

1.首先新建一个页面

![1548343601476](1548343601476.png)

2.然后在 nav.wxml 中构建代码

![1548343719694](1548343719694.png)

3.然后在 nav.js 中构建相应的点击事件绑定函数

![1548343937012](1548343937012.png)

4.我们在跳转的地方携带了参数，所以在目标页面需要接收参数数据，因为跳转的是input页面，所以我们去到input页面的 input.js 中的 onLoad 指定的函数中接收参数数据，因为这个函数在页面加载的时候最行被触发执行

![1548344113772](1548344113772.png)

**示例4：**实现导航跳转到带tabBar的页面

在nav.wxml中构建代码

![1548489982982](1548489982982.png)

效果图：

![1548490018448](1548490018448.png)

跳转后的效果图：

![1548490041568](1548490041568.png)

**示例5：**实现导航跳转到某个页面并携带参数id=2和name=小薇

在 nav.wxml 中构建代码

![1548380018482](1548380018482.png)

在 icon.js 中的onLoad函数中接收参数

![1548380103423](1548380103423.png)

测试效果如下

![1548380122454](1548380122454.png)

**小结：**

- **open-type**的值如果设置为navigate则可以拥有回退按钮；如果设置为redirect则没有回退按钮
- navigate、redirect这两值和switchTab这个值的区别在于前面两个不能跳转到带tabBar的页面；而switchTab可以
- 如果我们要在绑定的函数中实现跳转，我们可以通过小程序提供的导航接口实现跳转，如：
  - wx.navigateTo 和 open-type 设置 navigate 的效果是一样的
  - wx.redirectTo 和 open-type 设置 redirect 的效果是一样的
  - wx.switchTab 和 open-type 设置 switchTab 的效果是一样的

==注意：导航组件和导航接口所能实现的跳转全部是站内跳转==

## 14、媒体组件

官方开发文档：https://developers.weixin.qq.com/miniprogram/dev/component/video.html

==**需求：**==制作一个支持发弹幕的视频播放媒体页面

==**实现**==

1.首先新建一个页面

![1548380736960](1548380736960.png)

2.然后在 video.wxml 中构建代码

![1548381786766](1548381786766.png)

3.然后在 video.wxss 中设置样式

![1548381827981](1548381827981.png)

4.再然后在 video.js 中定义函数与变量

![1548381933783](1548381933783.png)

![1548381969990](1548381969990.png)

![1548381993140](1548381993140.png)

5.测试结果如下

![1548382021587](1548382021587.png)

## 15、ES6

​	CMAScript6 (以下简称ES6) 是javascript语言的下一代标准，已经在2015年6月正式发布了。Mozilla 公司将在这个标准的基础上，推出 javascript 2.0。(ES7)

​	ECMAScript 和 javascript 到底是什么关系？很多初学者会感到困惑，简单来说，ECMAScript 是 javascript 语言的国际标准，javascript 是 ECMAScript 的实现。

1996年11月，javascript 的创造者 Netscape 公司，决定将 javascript 提交给国际标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0版。

ES6 的目标，是使得 javascript 语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。

### 15.1、申明变量

申明关键字：==var==或==let==

var 申明的变量和 let 申明的变量区别：

- let 存在块级作用域，而 var 没有
- let 申明的变量不可以重复申明，但是可以赋值，而 var 的可以重复申明

### 15.2、箭头函数

箭头函数的语法：

```js
([形参列表]) => {
    函数体和返回值
}
```

箭头函数的特点：

1.如果只有一个参数，则"()"可以省略不写

![1548401482062](1548401482062.png)

2.如果函数体只有一条语句，则"{}"可以省略不写

![1548401652330](1548401652330.png)

3.不改变 this 指针的指向( 在接口请求案例中进行测试 )

### 15.3、申明类

![1548402408146](1548402408146.png)

### 15.4、模块功能

模块功能主要由两个命令构成：==export==和==import==

export 命令用于规定模块的对外接口；import 命令用于输入其他模块提供的功能。

==注意：==如果在html中的script里导入模块，则需要为script标签设置属性==type="module"==。

### 15.4.1、导出变量和常量

#### 15.4.1.1、普通 export 方式

语法：

```js
export 变量或常量;
```

![1548403793072](1548403793072.png)

使用常规方式导出变量或常量，那么在导入的文件中应该使用如下图所示的方式去导入

![1548403870187](1548403870187.png)

#### 15.4.1.2、default 的 export 方式

语法：

```js
export default {
    变量或常量1,
    变量或常量2,
    ...
    变量或常量n
}
```

![1548405125013](1548405125013.png)

如果使用这种方式导出变量和常量的话，那么在导入的文件中应该使用如下图所示的方式导入

![1548405244955](1548405244955.png)

### 15.4.2、导出函数

![1548405553354](1548405553354.png)

![1548405579002](1548405579002.png)

### 15.4.3、导出类

![1548405913374](1548405913374.png)

![1548405934910](1548405934910.png)

## 16、RESTful API

### 16.1、什么是 Restful

​	RESTful 是一种软件设计风格，主要用于==客户端==与==服务端==交互的软件，一般来说 RESTful API 基于 ==HTTP/HTTPS==协议，通过某个唯一标识符(URI)请求对应的服务器资源(Resource)。

主要包括 6 个方面：

![1548406179371](1548406179371.png)

### 16.2、RESTful API 的作用

​	为前端（APP端/PC浏览器端/微信端等等）提供一套简单并且统一的请求方式来从后端（服务器）获取需要的数据。

提供接口的方式：基于 http/https 协议

返回接口数据的形式主要为： JSON 也有少数为 XML

- 降低开发的复杂性
- 提高系统的可伸缩性

### 16.3、资源路径

​	在 RESTful API 中，每个资源路径对应一个唯一的资源，所以规定网址中不能有动词，只能有名词，并且一般来说复数。

例如：

```
https://api.youlongit.com/goods/list	//表示商品列表
https://api.youlongit.com/goods/details //商品详情
https：//api.youlongit.com/category/list 	//商品分类

为了方便开发与后期的版本迭代，可以在URI中加入版本号
https://api.youlongit.com/api/v1/goods/list	//表示商品列表
https://api.youlongit.com/api/v1/goods/details //商品详情
https：//api.youlongit.com/api/v1/category/list 	//商品分类
```

### 16.4、http/https 动词

对于资源，一般有 4 个操作，CURD（==增/删/改/查==）

```
GET/HEAD	从服务器获取资源(一项或多项)
POST		在服务器新建一个资源
PUT/PATCH	在服务器更新资源，服务器返回完整的属性
DELETE		从服务器删除资源

例如：
POST	/goods		创建商品内容
GET		/goods		获取全部商品信息
GET		/goods/1	获取主键id为1的商品
PUT		/goods/1	修改参数为1的商品
delete	/goods/1	删除参数为1的文章
```

### 16.5、过滤信息

​	当服务端需要返回的数据很多时，服务器不可能全部返回，此时我们可以在客户端携带过滤信息

比如：分页信息

```
?page=1				第一页的信息
?offset=10&limit=10	每页10条，偏移10
?name=php32			查询姓名以php32
```

### 16.6、响应状态码

服务端返回的信息，用来告诉客户端操作结果

| 状态码 | 含义        | 说明                 |
| ------ | ----------- | -------------------- |
| 200    | OK          | 操作成功，并返回数据 |
| 201    | CREATED     | 新建成功             |
| 202    | Accepted    | 修改成功             |
| 204    | NO CONTENT  | 删除成功             |
| 400    | BAD REQUEST | 请求语法错误         |
| 403    | Forbidden   | 请求没有权限的资源   |
| 5XX    |             | 服务器端错误         |

### 16.7、错误处理

如果状态码是 4xx 或者 5xx，需要告诉客户端对应的错误信息。以**json**格式返回，如：

```json
{
    "error":"错误信息"
}
```

### 16.8、返回结果

针对不同的操作，服务需要返回的结果应该符合这样的规范

```
GET /collections			返回资源列表(数组)  200
GET /collections/:id		返回单个资源   200
POST /collections			返回新生成的资源 201
PUT /collections/:id		返回资源的完整属性 201/202
PATCH /collections/:id		返回被修改的属性 201/202
DELETE /collections/:id		返回204状态码+空文档
```

### 16.9、推荐接口调试工具

postman：https://www.getpostman.com/apps

在 chrome 中也可以安装 postman 的扩展工具

## 17、常用的小程序 API

通过小程序提供的 API 接口 wx.request(OBJECT)来实现，它可以发起 HTTPS 网络请求。

==生产环境下：==

HTTPS ==证书==必须有效而且是 TLS1.2 及以上版本

可以设置 20个有效的 https域名

最好要设置一下 app.json 中的 request 请求的超时时间

==测试环境下：==

测试支持的并发数请求为5个

可以在微信提供的开发工具中不校验 https 证书

### 17.1、发起网络请求

官方开发文档：https://developers.weixin.qq.com/miniprogram/dev/api/wx.request.html

## 18、总结

事件分类：1）冒泡类型	2）非冒泡类型

事件绑定：

​	绑定方式:事件名="函数"

​	绑定方式:bind或catch

事件对象：最大的贡献就是为了传递参数给函数

​	我们事先需要在 wxml 文件的标签中以如下格式构建参数

​	data-参数名="参数值"

swiper滑块：轮播图

scroll-view组件：滚动加载，==注意：上下滚动加载时，一定给他一个高度==

ES6

​	1）调用父类构造器方法：super([实参列表])

​	2）模块功能中的导出(export)和导入(import)

发起网络请求

```js
wx.request({
    url: 'http://127.0.0.1/es6/code.php',
    //method:'post', //默认为get
    // data:{
    //   key:value
    // },
    // header: {
    //   'content-type': 'application/json' // 默认值
    // },
    success(res){
        console.log(res);
    }
})
```

