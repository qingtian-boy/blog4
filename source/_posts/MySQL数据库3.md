---
title: MySQL数据库3
date: 2019-02-20 17:00:15
tags: MySQL
---
# 一、昨日回顾

## 1. 知识回顾

1. 能够设置正确的字符集

   设置字符集：set names 字符集;

   设置什么样的字符集取决于客户端是什么字符集。

2. 能够理解字段属性的空值，默认值含义

   空值：就是NULL值，可以通过not null来设置不能使用NULL值，如果不设置该属性，则默认就是可以使用NULL值

   默认值：通过default关键字来进行设置，如果不设置，默认使用NULL值作为默认值
<!-- more -->
3. 能够理解字段属性的主键，自增长，唯一键含义

   主键：通过primary key关键字来进行设置

   1)主键从结构上来看是唯一的

   2)主键从数据的角度来看也是唯一的

   自增长：通过auto_increment关键字进行设置

   1)自增长需要跟随主键来进行设置

   2)如果不设置值，则该自增长字段的值将会在原有最大索引值的基础上+1进行填充

   唯一键：通过unique关键字来进行设置

   1)从结构上看，唯一键可以设置多个

   2)从数据上看，唯一键的值是唯一的


# 二、知识路径

- MYSQL基础设置

  ​	修改表结构

  ==目标：能够修改表结构==

- 表关系

- 高级数据操作

  ​	高级新增操作

  ​	子语句

  ​	聚合函数

- 运算符

- 高级查询

  ​	联合查询

  ​	子查询

  ​	连接查询

  ==目标：能够使用子语句进行操作==




# 三、今日课程内容：MYSQL数据库

## 1. MYSQL基础设置

### 修改表结构

#### 向已有的一个表中添加字段

语句语法：==**alter table** 表名 **add** 新字段名 字段类型 [字段属性列表];== 

**==操作演示==**：

![1539220725453](2)



#### 删除已有表中的某个字段

语句语法：==**alter table** 表名 **drop** 字段名;==

**==操作演示==**：

![1539220866626](3)



#### 改变已有表中某个字段的名字

语句语法：==**alter table** 表名 **change** 旧字段名 新字段名 新字段类型 [字段属性];== 

TIPS：如果只想单纯改名，则必须在改名的同时维持原属性不变写一次。 

**==操作演示==**：

![1539221166874](4)



#### 修改表字段的类型或属性

语句语法：==**alter table** 表名 **modify** 字段名 字段新类型 [字段新属性列表];== 

**==操作演示==**：

![1539221410543](5)



## 2. 表关系

MYSQL中三种典型的关系：1）一对一；2）一对多；3）多对多；

典型的一对一：学生信息表 VS 学生履历表    

典型的一对多：学生信息表 VS 班级表   

典型的多对多：班级信息表 VS 教师信息表   



## 3. 高级数据操作

### 高级新增操作

#### replace语句

TIPS：replace实际上就是替换insert语句中的insert关键字的，实现的功能和insert语句一模一样。 

**==操作演示==**：

![1539222642062](6)



#### 一次性新增多条记录

语句语法1：==**insert into** 表名 **values** (数据列表1), (数据列表2)…., (数据列表n);==

语句语法2：==**insert into** 表名 (字段1, 字段2, …, 字段n) **values** (数据列表1), (数据列表2)…., (数据列表n);==

**==操作演示==**：

![1539223859615](7)



#### set方式新增数据

语句语法：==**insert into** 表名 **set** 字段1=字段1值, 字段2=字段2值, …, 字段n=字段n值;== 

**==操作演示==**：

![1539224163343](8)



### 子语句

#### where子句    ==★==

作用：用于条件过滤，得到真实的结果。 

**==操作演示==**：

![1539224421387](9)



#### group by语句

作用：用于分组统计，常与聚合函数一起使用。

TIPS：在查询的时候，如果==group by==后面指定了字段，则会额外根据指定的字段进行分组；分组的意思就是，在最终展示的数据中，不会出现group by后面指定字段值==完全相等==的情况，即使查询的数据中有相同的值，也只会显示一条。 

**==操作演示==**：

创建一个如以下条件的测试表：

```mysql
##表结构如下
学生表
student
主键id,学生姓名,学号,学生年龄
id,name,numb,age

create table student(
id int unsigned primary key auto_increment,
name varchar(30),
numb varchar(10),
age tinyint unsigned not null default 0
);

##构建测试数据
insert into student values
(null, 'zhangsan', 'N10086', 12),
(null, 'lisi', 'N10087', 13),
(null, 'wangwu', 'N10088', 14),
(null, 'zhaoliu', 'N10089', 12),
(null, 'tianqi', 'N10090', 14),
(null, 'zhaoliu', 'N10091', 12);
```

![1539225191453](10)



==细节==：group by不仅能够指定一个字段分组，还可以指定多个字段进行分组。 

**==操作演示==**：

![1539225455944](11)



**==小结==**：group by可以对指定的字段进行分组，就是将指定字段重复的数据只保留第一条。



#### having语句

作用：功能上类似于where语句，负责在结果中再次进行条件过滤。 

**==操作演示==**：

![1539225869704](12)



**==小结==**：having主要用于二次条件过滤；



#### order by子句   ==★==

作用：用来按照指定的字段进行==排序==的。

**==操作演示1==**：==默认情况==下，是按照指定字段==升序的顺序==排序的。

![1539226121016](13)



**==操作演示2==**：如果不加上asc默认就是以asc升序排序 。

![1539226224567](14)



**==操作演示3==**：按照降序排序：使用关键字==desc==。

![1539226388600](15)



==**小结**==：order by可以实现按照指定的字段值进行排序。



#### limit子句    ==★==

作用：用来限制查询出来的记录的条数。

**==操作演示==**：

![1539227477375](16)



==细节==：limit另外一种结构：==limit M, D;==   M表示==偏移量==，D表示==每次查询的长度==。 

**==操作演示==**：

![1539227985734](17)



**==小结==**：

1）limit第一个结构直接在limit后面指定限制的数据条数；

2）limit第二个结构是limit M, D;    M表示偏移量（即重新规划后的索引值）；D表示每次限定的条数



## 4. 聚合函数

涉及的聚合函数：

> count函数    统计指定字段在表中的记录总条数，不统计null值。
>
> max函数    统计指定字段数据的最大值。
>
> min函数    统计指定字段数据的最小值。
>
> avg函数    统计指定字段所有符合条件数据的平均值。(average)
>
> sum函数    统计指定字段所有符合条件数据的总和。
>
> concat函数    用指定的字符连接指定多个字段的数据。



**==演示案例==**：

创建一个如以下条件的测试表：

```mysql
##表结构如下
学生表
stu1
主键id,学生姓名,学生学号,学生年龄,学生成绩
id,name,numb,age,score

create table stu1(
id int unsigned primary key auto_increment,
name varchar(30),
numb varchar(10),
age tinyint unsigned not null default 0,
score tinyint unsigned not null default 0
);

##测试数据如下
insert into stu1 values
(null, 'zhangsan', 'n10082', 12, 96),
(null, 'lisi', 'n10083', 11, 72),
(null, 'wangwu', 'n10084', 14, 59),
(null, 'zhaoliu', 'n10085', 12, 90),
(null, 'tianqi', 'n10086', 13, 84);
```

**==需求1==**：统计查询所有学生中年龄大于等于13岁的学生总共有多少个。

==**解答1**==：

我们通常情况下不在count函数中单独指定某个字段，而是直接指定'*';

![1539228856618](18)



我们可以为字段列表中的字段取别名：直接通过==as==关键字实现

![1539229211423](19)



**==需求2==**：统计查询所有学生中考试成绩的最高分、最低分和平均分。

==**解答2**==：

![1539229406472](20)



**==需求3==**：统计查询所有学生的总分数。

==**解答3**==：

![1539229531691](21)



**==需求4==**：查询所有学生数据，要求姓名和学号以  "姓名-学号"  格式连接展示。

==**解答4**==：

![1539229748504](22)



## 5. 运算符

TIPS：MYSQL中，

1）运算符可以直接通过==select结构==进行**==数据的==**运算执行操作，这里的select就相当于PHP中的echo；

2）运算符如果写在查询语句的字段列表中，则将会直接计算结果；

3）运算符如果写在了条件语句中，则计算的结果还将会转换为bool值；



### 算数运算符（+、-、*、/、% ）

TIPS：算数运算符常用于==字段列表中==使用。

**==演示案例==**：

**==需求1==**：直接计算100%3, 10*20, 40-100的值。

**==解答1==**：

![1539230022968](23)





创建一个如以下条件的测试表：

```mysql
##表结构如下
学生表
stu2
主键id,学生姓名,期中考成绩,期末考成绩
id,name,qz_score,qm_score

create table stu2(
id int unsigned primary key auto_increment,
name varchar(30),
qz_score smallint,
qm_score smallint
);

##测试数据如下
insert into stu2 values
(null, 'zhangsan',  46, 96),
(null, 'lisi', 81, 72),
(null, 'wangwu', 62, 53),
(null, 'zhaoliu', 86, 95),
(null, 'tianqi', 80, 84);
```

**==需求2==**：计算各学员期末考与期中考的分数差。

**==解答2==**：

![1539230286488](24)



### 比较运算符（\>、>=、<、<=、=、！=或<>）

TIPS：比较运算符多用于==条件语句中==使用。



**==演示案例==**：

1）测试在条件语句中使用；

![1539240965757](25)



2）测试在字段列表中使用；

![1539241103839](26)

得到的0值表示false，得到的1值表示true.



### 逻辑运算符（and、or、not）

TIPS：1)and表示左右两边都为真整个运算才为真；2）or表示左右两边只要有一个为真整个运算才为真；3）not表示取反，原来为真加上not就为假，原来为假加上not就为真；



**==演示案例==**：

**==需求1==**：查询stu2表中，期中考试大于等于80并且期末考试也大于等于80分的学员的全部信息；

**==解答1==**：

![1539241381632](27)



**==需求2==**：查询stu2表中，期中考试大于等于80==或者==期末考试也大于等于80分的学员信息；

**==解答2==**：

![1539241713536](28)



### in运算符    ==★==

TIPS：in表示在==集合==中才为true，不在集合中则为false；



**==演示案例==**：

**==需求1==**：查询stu2表中，期中考试成绩为81, 82, 83, 84, 91, 92, 93分的学员都有哪些；

**==解答1==**：

![1539242211220](29)



### is运算符

TIPS：is运算符有两种搭配：1）和null搭配（is null和is not null）；2）和true搭配（is true和is not true）；

is null表示字段为空的值则返回true; is not null表示字段不为空则返回true。



**==演示案例==**：

按照以下条件创建表：

```mysql
##表结构如下
学生表
stu3
主键id,学生姓名,年龄
id,name,age

create table stu3(
id int unsigned primary key auto_increment,
name varchar(30),
age tinyint
);

#测试数据
insert into stu3 values
(null, '木吒', 12),
(null, '李靖', 13),
(null, '殷十娘', 14),
(null, '啸天', 0),
(null, null, 16);
```

**==需求==**：1）查询name为null的所有成员的信息；

​	2）查询name不为null的所有成员的信息；

​	3）查询age值转换为布尔值为true的所有成员的信息；

**==解答==**：

1）

![1539242435196](30)

2）

![1539242512280](31)

3）

![1539242696293](32)



### like运算符（模糊匹配）

TIPS：like是用于模糊匹配搜索的。like运算符经常与“==%==”一起使用，“%”表示==任意个数==的==任意字符==。 



**==演示案例==**：

创建一个如以下条件的测试表：

```mysql
##表结构如下
新闻表
news
主键id,标题,内容
id,title,content

create table news(
id int unsigned primary key auto_increment,
title varchar(30),
content text
);

##添加测试数据在day9.sql文件中
insert into news values
(null, '人民日报钟声：牢记历史是为了更好开创未来', '日方应在正确对待历史问题上切实做到表里如一、言行如一、始终如一。中日关系向前发展的重要机遇值得珍惜73年前的8月15日，日本宣布无条件投降。其后岁岁年年，日本如何纪念这一天，都折射出日本认同国际正义公理与否的真相，也牵动着包括中国人民在内的众多二战受害国人民的情感。'),
(null, '九个方面，看总书记如何用好马克思主义', '今年第11期《求是》杂志文章《把马克思主义哲学作为自己的看家本领》，列举了不少总书记活用马哲原理进行理论创新的鲜活例子，对那些觉得马哲原理“说起来容易做起来难”的党员干部作了针对性的答疑解惑，是一次修炼哲学修养、提升从政经验值的好机会。'),
(null, '发改委:下决心解决房地产问题 坚决遏制房价上涨', '8月15日，国务院新闻办就当前经济社会发展有关情况举行吹风会，国家发展改革委秘书长、国民经济综合司司长、新闻发言人丛亮表示，下决心解决好房地产的问题，要坚持因城施策，促进供求平衡，合理引导预期，整治市场秩序，坚决遏制房价上涨，加快建立促进房地产市场平稳健康发展的长效机制。'),
(null, '安倍连续6年在“战争死难者追悼仪式”上不提加害责任 渐成惯例', '据日本共同社8月15日报道，日本首相安倍晋三自第二次执政以来，在每年的“全国战争死难者追悼仪式”上的致辞中总是避免提及日本的加害责任。他今年也仅表示“不让战争惨祸重演。将谦虚面对历史”。安倍在致辞中不向亚洲各国道歉的行为逐渐成为惯例。'),
(null, '农业农村部：炭疽疫情可防可控，正规渠道购买的牛羊肉可食用', '农业农村部网站8月15日消息， 近期，黑龙江桦南县一种畜场发生一起羊炭疽疫情、内蒙古通辽市科尔沁区胜利村发生一起牛炭疽疫情。就当前炭疽疫情防控情况，记者采访了农业农村部兽医局负责人。');
```

**==需求==**：查询新闻内容包含"日本"关键字新闻的新闻id和新闻标题。

**==解答==**：

![1539244301390](33)



**==小结==**：like用于中小项目做搜索功能。



## 6. 高级查询

TIPS：高级查询部分包括：1）联合查询；2）子查询；3）连接查询；



### 联合查询

TIPS：联合查询主要包括：1）union；2）union all



#### union联合查询

TIPS：union联合查询其实就是通过==union==关键字将多条查询SQL语句连接起来。

**==演示案例==**：

创建一个以下条件的数据表：

```mysql
##数据表结构如下
表名：teacher
中文：主键id,教师姓名,教师工号,带课天数,所带班级
字段：id,t_name,numb,days,class_name
类型：int,varchar(30),varchar(50),tinyint,varchar(30)

create table teacher(
id int unsigned primary key auto_increment,
t_name varchar(30),
numb varchar(50),
days tinyint unsigned,
class_name varchar(30)
);

##测试数据如下
insert into teacher values
(null, '孔子', 'N10086', 21, 'php29'),
(null, '孟子', 'N10087', 24, 'php28'),
(null, '庄子', 'N10017', 17, 'php29'),
(null, '荀子', 'N10019', 18, 'php28'),
(null, '墨子', 'N10010', 30, 'php29');
```

**==需求1==**：查询带课天数最多的教师的记录。

**==解答1==**：

![1539244723306](34)



**==需求2==**：查询带课天数最少的教师的记录。

**==解答2==**：

![1539244797608](35)



**==需求3==**：同时查询带课天数最多的教师和带课天数最少的教师的记录。

**==解答3==**：

![1539245227366](36)



**==小结==**：union关键字能够将业务逻辑相反的==查询语句==连接起来做一次执行。



**==细节==**：使用union联合查询时，每个查询语句中所查的字段列表须要保持一致。

![1539245520880](37)



**==小结==**：我们在使用联合查询的过程中，上下查询语句所查字段需要保持一致，否则即便能够查得数据，数据也没有意义。



#### union all

TIPS：union all和union只有一个区别，就是在保留重复数据上有所区别。



**==需求==**：查询带课天数最多的前三个教师和带课天数最少的前三个教师的记录。

**==解答==**：

分开来查询

查询带课天数最多的三个老师：

![1539245937254](40)

查询带课天数最少的三个老师：

![1539245974261](41)



1）使用union实现

![1539245850655](38)



2）使用union all实现

![1539245890498](39)



==**小结**==：union和union all唯一的区别是，union会去掉重复的记录，而union all不会去掉重复的记录。



### 子查询

按照查询结果来进行划分：1）标量子查询；2）列子查询；3）行子查询；4）表子查询；



#### 标量子查询

TIPS：标量子查询中的标量指的是 ==一个单个的值==。

概念：标量子查询就是 ==本条查询语句的查询条件== 是 ==另一个查询语句查询出来的单个值==。



**==演示案例==**：

创建以下条件的表：

```mysql
##数据表如下
表1：teacher1
中文：主键id,教师姓名,教师工号
字段：id,name,numb
类型：int,varchar(30),varchar(50)

create table teacher1(
id int unsigned primary key auto_increment,
name varchar(30),
numb varchar(50)
);

表2：teacher_class
中文：主键id,teacher1表id,带课天数,所带班级
字段：id,teacher_id,days,class_name
类型：int,int,tinyint,varchar(30)

create table teacher_class(
id int unsigned primary key auto_increment,
teacher_id int unsigned,
days tinyint unsigned,
class_name varchar(30)
);

##测试数据如下
insert into teacher1 values
(null, '孔子', 'N10086'),
(null, '孟子', 'N10087'),
(null, '庄子', 'N10017'),
(null, '荀子', 'N10019'),
(null, '墨子', 'N10010');

insert into teacher_class values
(null, 1, 21, 'php30'),
(null, 3, 24, 'php31'),
(null, 2, 17, 'php30'),
(null, 2, 17, 'php31'),
(null, 5, 30, 'php30');
```

**==已知==**：教师的姓名为 孔子。

**==求==**：这个老师所有的带班信息。

**==解答==**：

思路拆解：

先根据老师姓名查得教师id

![1539247428710](42)

然后再根据教师的id值查找这个教师所带的班级信息

![1539247452075](43)

使用标量子查询做简化：

![1539247699434](44)



#### 列子查询

概念：本条查询语句的==查询条件== 是 另一个查询语句查询出来的==一列结果==。

**==演示案例==**：使用teacher1表和teacher_class表

![1539247810786](45)

**==已知==**：某个教师的姓名为 孔子，另一个教师的工号为N10087。

**==求==**：这两个老师相关带课信息。

**==解答==**：

思路分解

先根据一个老师的教师姓名孔子和另外一个老师的工号查询这两个老师的id

![1539248183702](46)

然后在根据两个老师的id值查两个老师的带课信息

![1539248204398](47)



使用列子查询将以上查询操作合二为一：

![1539248442565](48)



#### 行子查询

概念：本条查询语句中的==查询条件== 是 另一个查询语句所查出来的==一行记录==。

**==演示案例==**：使用teacher1表

创建如下测试表：

```mysql
##表结构如下
表1：stu4
字段：name,age,teacher_name,teacher_numb,class_name
翻译：学生姓名,学生年龄,班主任姓名,班主任工号,所属班级
类型：varchar(30),tinyint,varchar(30),varchar(50),varchar(30)

create table stu4(
name varchar(30),
age tinyint,
teacher_name varchar(30),
teacher_numb varchar(50),
class_name varchar(30)
);

##测试数据如下
insert into stu4 values
('韩信', 12, '荀子', 'N10019', 'php28'),
('萧何', 16, '荀子', 'N10019', 'php29'),
('张良', 13, '孔子', 'N10086', 'php28'),
('樊哙', 15, '墨子', 'N10010', 'php26'),
('钟离昧', 12, '庄子', 'N10017', 'php29'),
('司马欣', 14, '孟子', 'N10087', 'php23'),
('陈平', 13, '孔子', 'N10086', 'php29');

##设置干扰数据
insert into teacher1 values (null, '荀子', 'N10020');
```

教师表teacher1的数据：

![1539248822289](50)

学生表stu4的数据：

![1539248837506](51)



**==已知==**：班主任的id值为4。

**==求==**：其所带班级中学生的信息。

思路分解

先根据教师的id查询得到教师的姓名和工号

![1539249129782](52)

然后再根据教师的名称和教师的工号查询该教师所带学生的信息

![1539249144988](53)



使用行子查询的方式将上述目标合二为一：

![1539249604341](54)

行子查询指的是本条查询语句的查询条件是另一条查询语句查询出来的一行结果。



#### 表子查询

概念：本条查询语句==所查询的表== 是 另一个查询语句查询出来的一个虚==拟表结果集==。

**==演示案例==**：使用了stu4表

创建以下条件的表：

```mysql
##根据stu4表构建stu5表
create table stu5 like stu4;

##删除stu5表中的teacher_name和teacher_numb字段
alter table stu5 drop teacher_name;
alter table stu5 drop teacher_numb;

##复制stu4表中的数据到stu5中    (蠕虫复制)
insert into stu5 (name, age, class_name) (select name, age, class_name from stu4 where 1);
```

**==要求==**：查询stu5表中php28和php29班所有学生中 年龄大于14岁学生的信息。

**==解答==**：

![1539250799653](55)



**==小结==**：

1. 在表子查询中，我们需要为虚拟表取别名，否则执行将会失败。



#### exists子查询

TIPS：exists子查询和查询的具体数据没有关系，只和是否查询的出数据有关。

**==演示案例==**：使用了stu4表和teacher1表。

根据以下要求调整数据表：

```mysql
##删除teacher1表中numb为N10020的干扰数据
delete from teacher1 where id=6;
```



**==要求==**：查询stu4表中所有 属于在职老师带领 的学生信息？ 

**==解答==**：

首先，模拟一个老师离职，



然后使用exists子查询实现要求的目标：





**==小结==**：





## 7. 全天总结

1. 能够使用高级新增语句

   1）replace替换insert关键字；

   2）一次性新增多条数据：    

   ​	a）insert into 表名 values (新值列表1), (新值列表2), ...(新值列表n);

   ​	b）insert into 表名 (字段列表) values (新值列表1), (新值列表2), ...(新值列表n);

   3）set方式实现新增：insert into 表名 set 字段1=字段1值, 字段2=字段2值, ..., 字段n=字段n值;

2. 能够对数据按指定顺序进行修改或删除

   排序：使用order by 排序字段名 来实现排序

   order by如果写上asc或者不写表示默认情况，默认情况就是按照从上往下升序的顺序进行排序；

   order by如果写上desc表示将会按照从上往下降序的顺序进行排序。

3. 能够理解select语句高级查询语法

   联合查询：关键字包括union和union all

   联合查询指的就是将业务逻辑相反的两条==查询语句==通过以上两种关键字连接起来进行一次执行。

   union和union all的区别是union将会去掉重复的数据，而union all不会去掉重复的数据。

4. 理解并使用聚合函数
   ==count==、max、min、avg、sum、concat函数

5. 理解并使用where中常见运算符

   1)算数运算符  

   2)比较运算符

   3)逻辑运算符

   4)in运算符

   5)like运算符

6. 能够写出联合查询语句

   (查询语句)

   union

   (查询语句);

7. 能够理解order by在联合查询中的作用

   order by用于排序

8. 能够理解4种不同类型的子查询

   标量子查询：本条查询语句的查询条件是另外一条查询语句查询得到的单个值结果；

   列子查询：本条查询语句的查询条件是另外一条查询语句查询得到的一列结果；

   行子查询：本条查询语句的查询条件是另外一条查询语句查询出来的一行结果；

   表子查询：本条查询语句查询的表是另外一个查询语句查询得到的一个虚拟表结果集。不要忘了给虚拟表取别名

9. 能够理解并使用标量子查询

10. 能够理解并使用列子查询

    
