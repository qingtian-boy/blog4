---
title: js09
date: 2019-02-20 14:37:45
tags: JS
---
JavaScript从入门到精通（八）

# 一、JS原型链

## 1、原型对象

当系统加载构造函数的同时，会自动在内存中生成一个对象。我们把这个对象就称之为“原型对象”。

![img](wps3A9C.tmp.jpg) 

由以上图解可知，Person构造函数与Person原型对象是相对独立，不存在谁包含谁。但是两者之间又有一定的联系：

① Person构造函数中存在一个属性：prototype指向了Person的原型对象

② Person原型对象中存在一个属性：constructor指向了Person的构造函数
<!-- more -->
![img](wps3A9D.tmp.jpg) 

## 2、获取原型对象

① var 原型对象 = 构造函数.prototype（最常用）

② var原型对象 = 实例对象.__proto__

![img](wps3A9E.tmp.jpg) 

## 3、原型对象的作用

当构造函数的实例化对象访问一个不存在的属性或方法时，系统会自动到当前构造函数所指向的原型对象中去寻找，如找到，则直接使用。

![img](wps3A9F.tmp.jpg) 

原理图：

![img](wps3AA0.tmp.jpg) 

## 4、原型对象案例

![img](wps3AA1.tmp.jpg) 

## 5、原型链

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性

 

① 搜索首先从对象实例本身开始

② 如果在实例中找到了具有给定名字的属性，则返回该属性的值

③ 如果没有找到，则继续搜索指针指向的原型对象，查找具有给定名字的属性

④ 如果在原型对象中找到了这个属性，则返回该属性的值

⑤ 如果还是找不到，就到原型的原型去找，依次类推。

⑥ 如果直到最顶层的Object.prototype还是找不到，则返回undefined。

![img](wps3AA2.tmp.jpg) 

## 6、证明原型链的存在

![img](wps3AA3.tmp.jpg) 

# 二、call与apply方法

## 1、this关键字

在JS中，存在一个特殊的关键字this。在不同的运行环境下，其this的指向的也是不同的。

① 行内绑定，this指向window对象

② 动态绑定与事件监听，this指向当前dom对象

③ 构造函数，this指向当前实例化对象

总结一下：函数内部的this，就是谁调用这个函数，函数内部的this就指向谁！

问题：我们可不可以人为的修改函数内部的this指向呢？

答：使用call或apply方法，任选其一，因为两者的功能是完全一致的。

## 2、call或apply方法

call方法基本语法：可能同时拥有多个参数

函数名称.call(thisObj,函数参数1,函数参数2...);

参数说明：

thisObj ：this所指向的对象

函数参数列表：函数如果有参数，从第二个位置开始写起，参数与参数使用逗号隔开

apply方法基本语法：最多只能有两个参数，第二个参数是一个数组

函数名称.apply(thisObj,[函数参数1，函数函数2...]);

所以注意：call方法与apply方法的功能完全一致的，只是两者的语法略有区别。

① call方法可以同时拥有多个参数

② apply方法最多只能拥有两个参数

## 3、call与apply案例

案例1：更改speak函数内的this指向

![img](wps3AA4.tmp.jpg) 

案例2：DOM操作中的this

![img](wps3AA5.tmp.jpg) 

# 三、JS中的继承

## 1、什么是继承

\- 现实生活中的继承

\- 程序中的继承

所谓的继承，其实就是在子类(子对象)能够使用父类(父对象)中的属性及方法；

赋予后辈调用祖辈资源的权限，就是继承；

## 2、JS中的继承

在有些面向对象的编程语言中，我们可以使用关键字extends来实现类的继承，但是在JS中没有extends这个关键字，如果想实现继承，必须通过模拟的方式。

## 3、使用call或apply方法实现继承

![img](wps3AA6.tmp.jpg) 

call或apply方法实现继承其核心就是更改父类构造函数中的this指向。

## 4、使用原型实现继承

![img](wps3AA7.tmp.jpg) 

原理图：

![img](wps3AA8.tmp.jpg) 

# 四、JS中的闭包

## 1、作用域链

根据作用域链的原则，在JS中，允许在局部作用域中调用全局变量。

但是在全局作用域中，无法直接调用局部变量。

![img](wps3AA9.tmp.jpg) 

运行结果：引用错误，n没有定义，因为在函数f1执行完毕后，其内部的变量以及函数都会被JS的垃圾回收机制所销毁。

## 2、JS的垃圾回收机制

JS垃圾回收机制核心：引用计数器

![img](wps3AAA.tmp.jpg) 

说明：我们在系统中声明的局部变量或函数，其在计算机内存中都会开辟一块内存空间。然后将引用计数器初始化为0。如果在全局作用域中，有变量对其引用时，系统会自动进行+1操作，当函数执行完毕后，系统会自动判断当前内存区域的引用计数器是否为0，如果为0代表没有被引用，则自动回收。反之，则不回收。

## 3、函数闭包

出于种种原因，我们有时候需要获取函数内部的局部变量。这个时候怎么办呢？

答：使用函数闭包

JS中函数的两种常见写法：

function f2() {}

① f2() ：找到这个函数在内存中的首地址并执行

② f2  ：返回这个函数在内存中的首地址，未执行

var f2 = function() {}

f2()

 

基本语法：

![img](wps3AAB.tmp.jpg) 

记住：函数中的函数，把内层函数的首地址作为函数的返回值。

![img](wps3ABC.tmp.jpg) 

## 4、闭包的作用

① 读取函数内部的局部变量（局部变量不会被JS垃圾回收机制所回收）

② 让局部变量一直驻留在内存中，类似于模拟PHP中的静态变量

## 5、闭包的作用（模拟静态变量）

![img](wps3ABD.tmp.jpg) 

## 6、闭包的案例

![img](wps3ABE.tmp.jpg) 

运行结果：没单击一个li标签，都会弹出4。为什么？

因为：onclick是异步执行的，必须等到我们单击时才开始执行，但是整个for循环已经很早就执行完毕后。

以上代码等价于：

for循环执行，执行结束后i = 4

//lis[0].onclick = function() {alert(i);}

//lis[1].onclick = function() {alert(i);}

特别提示：在JS中，代码分为同步执行与异步执行。大部分代码都是同步执行的，但是有三种情况比较特殊都是异步执行的：定时器 + 事件绑定 + Ajax

![img](wps3ABF.tmp.jpg) 

## 7、点赞案例（糗事百科）

![img](wps3AC0.tmp.jpg) 

特别说明：注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大，因此不能滥用闭包，否则会造成网页的性能问题。

# 五、综合案例：贪吃蛇

## 1、贪吃蛇架构设计

完全采用面向对象的编程思想。

面向对象的核心：把一个系统分为为若干个事务，每个事务就是一个对象。

① 地图（宽度和高度，蛇必须在地图范围内进行相关操作）

② 食物（宽度和高度，食物在地图中会随机出现）

③ 蛇（宽度和高度，运行、可以改变运行方向、变长度）

## 2、地图类的设计

JS中，一个类是由属性+方法构成的。

地图类属性：

宽度 ：800px

高度 ：400px

背景颜色 ：灰色，#dddddd

定位方式 ：absolute绝对定位

地图类方法：

显示方法 ：把地图按照上面的属性进行展示

![img](wps3AC1.tmp.jpg) 

以上就是地图类的定义，但是其代码并没有执行，必须在window.onload中实例化对象，调用show方法，才能正常显示：

![img](wps3AC2.tmp.jpg) 

## 3、食物类的设计

食物类也是通过属性+方法构成的。

食物有哪些属性？

宽度：20px

高度：20px

背景颜色：绿色

定位方式：absolute绝对定位

横纵坐标：x与y，而且坐标不是固定的，必须要随机出现

 

食物有哪些方法？

显示方法：show

![img](wps3AC3.tmp.jpg) 

在window.onload方法中，实例化Food类，生成food对象。

![img](wps3AC4.tmp.jpg) 

## 4、让食物可以实现随机出现

核心：更改食物的横纵坐标

x ：横坐标必须在0-39之间（800/20 = 40个格子，坐标都是从0开始）

y ：纵坐标必须在0-19之间（400/20 = 20个格子，坐标都是从0开始）

Math.random()随机数公式：

0 – 39 ：Math.floor(Math.random()  (39 – 0 + 1) + 0);

0 – 19 ：Math.floor(Math.random()  (19 – 0 + 1) + 0);

![img](wps3AC5.tmp.jpg) 

## 5、蛇类的定义

属性：

宽度：20px

高度：20px

定位方式：absolute

蛇节设计：一共有3节，要求横坐标连续，纵坐标相等，每一节颜色不同

![img](wps3AC6.tmp.jpg) 

方法：

显示方法：show

![img](wps3AC7.tmp.jpg) 

在window.onload中实例化Snake类，生成对象。调用show方法。

![img](wps3AC8.tmp.jpg) 

## 6、让蛇运动起来

方法：

move方法，专门用于实现蛇的运动，所谓运动的核心：

蛇身跟着蛇头跑：

蛇身如果想进行运动，则其除蛇头的每一节都要和前几一个蛇节进行横纵坐标的交换。

蛇头决定运动方向的：

① 向右，蛇头横坐标 + 1

② 向下，蛇头纵坐标 + 1

③ 向上，蛇头总坐标 – 1

④ 向左，蛇头横坐标 – 1 

![img](wps3AC9.tmp.jpg) 

在window.onload中，使用定时器调用move方法，让蛇运动起来：

![img](wps3ACA.tmp.jpg) 

## 7、解决蛇重复生成divbug

只需要在show方法中进行判断，让div只生成一次即可，以后每次运动只调整横纵坐标。

![img](wps3ACB.tmp.jpg) 

## 8、让其可以根据键盘的键值改变方向

事件对象.keyCode，左37上38右39下40

![img](wps3ADB.tmp.jpg) 

在Snake类中定义setDirect方法：

![img](wps3ADC.tmp.jpg) 

## 9、让蛇吃到食物

如果蛇头横纵坐标与食物的横纵坐标相同，代表吃到食物。

![img](wps3ADD.tmp.jpg) 

问题：食物会重复出现？

答：让食物只生成1次，下一次更改坐标即可。

![img](wps3ADE.tmp.jpg) 

## 10、两个小问题

① 撞墙死情况

② 吃到自己死情况