---
title: laravel框架02
date: 2019-03-02 19:32:32
tags: laravel
---
# 目录

[TOC]

# 一、昨日回顾

## 1、知识回顾

**能够使用 php artisan serve 方式运行 Laravel 项目**

​	使用黑窗口进入项目的根目录下执行：php artisan serve

**能够使用 composer 方式部署 Laravel 框架项目**

​	composer create-project --prefer-dist  laravel/laravel  test  版本号(*)

​	参数说明：

​		create-project	表示使用composer安装Laravel框架

​		--prefer-dist		表示下载安装使用压缩包方式下载

​		laravel/laravel	软件名称，格式：开发者名称/项目名称

​		test(项目名称)	表示把Laravel框架存储到当前目录下的test目录中
<!-- more -->
​		版本号			*表示最后一个版本，指定安装那个版本时使用	

**能够解释 Laravel 框架中的主要目录结构**

​	|- app/	应用目录
​		|- Http/	应用的Http请求处理都在这里进行
​			|-Controllers/	控制器存储目录【控制器】

​	|- config/	配置文件存储目录
​		|- app.php	系统核心配置文件
​		|- database.php	数据库配置文件

​	|- routes/	路由文件存储目录
​		|- web.php	主路由文件【路由文件】

**能够说出 Laravel 框架中的控制器所在的目录**

​	app/Http/Controllers/

**能够使用命令行创建自定义控制器**

​	使用黑窗口进入项目的根目录下执行：php artisan make:controller [目录/]控制器名称

**能够说出 Laravel 框架定义路由的文件的名称**

​	routes/web.php

**能够说出 Laravel 框架中的 get、post 两种基础路由**

​	Route::get('admin', 'Admin\AdminController@index');

​	Route::post('admin', 'Admin\AdminController@add');

**能够说出 Laravel 框架中控制器文件的命名规则**

​	使用大驼峰法，例如：AdminController.php，主要由控制器名+Controller+.php


# 二、视图

在Laravel中视图文件都是保存在resources/views/目录下，而我们的页面静态资源都是保存在public目录下。

Laravel中的视图都是以"==视图名称.blade.php=="为文件名。

Laravel框架中的模板有两种：

普通模板：直接以"视图名称.php"为模板文件名，这种模板不支持使用Laravel内置的blade模板引擎的语法，只支持PHP原生语法，当然效率高点。

blade模板：直接以"==视图名称.blade.php=="为模板文件名，这种模板支持使用Laravel内置的blade模板引擎的语法。

> 注意：当视图目录中出现2套同名的模板时，优先加载的是blade模板。

## 1、控制器中载入模板

```PHP
语法： return view('视图目录/视图名称');
```

## 2、普通模板

控制器代码如下所示：

```php
public function index(){
    return view('index')->with('title', '我是页面标题');
}
```

控制器代码如下所示：

![1545984562210](1545984562210.png)

视图代码如下所示：

![1545984588655](1545984588655.png)

路由地址如下所示：

![1545984616638](1545984616638.png)

效果如下所示：

![1545984626533](1545984626533.png)

> 注意：
>
> ​	Laravel框架的模板文件后缀必须是：*.blade.php；否则模板中的变量无法解析。

![1545984745591](1545984745591.png)

![1545984769349](1545984769349.png)

![1545984777701](1545984777701.png)

## 3、对模板进行赋值

```
在控制器中对模板进行赋值，有2种方式分别为：with、view函数第二个参数赋值
```

## 3.1 使用with方法赋值

```
语法：view('视图名称')->with('变量名', '变量值')->with('变量名', '变量值')......
```

控制器代码如下所示：

![1545985118102](1545985118102.png)

视图代码如下所示：

![1545985153368](1545985153368.png)

效果如下所示：

![1545985167244](1545985167244.png)

## 3.2 使用view第二个参数赋值

```
语法：view('视图名称', $array);

参数说明：
	$array 数组，要赋值到视图中的数据，每个成员的下标在视图中就是变量名。

```

控制器代码如下所示：

![1545985382949](1545985382949.png)

视图代码如下所示：

![1545985408886](1545985408886.png)

效果如下：

![1545985419462](1545985419462.png)

# 三、blade(模板)语法

## 1、直接输出标量类型的数据

```PHP
语法： { { 变量名 } }
```

## 2、输出HTML代码

```html
默认情况下，为了防止网站遭到XSS攻击，Laravel默认会把所有的具有代码性的内容全部进行实体字符转义。这种转义会有时候导致我们要输出的内容，达不到我们要的效果。
例如：一段经过富文本编辑器排版的图文。
```

PHP代码如下图所示：

![1545986483560](1545986483560.png)

视图代码如下图所示：

![1545986452382](1545986452382.png)

结果如下图所示：

![1545986393701](1545986393701.png)

> 注意：
>
> ​	如果真的要输出HTML原生的代码数据，则需要使用{!! 变量名 !!}
>
> ​	在Laravel的blade模板中，我们可以使用原生的PHP函数，也可以直接写PHP原生代码。

## 3、注释

```PHP
语法：{ {-- 需要注释的内容 --} }
```

> 注意：
>
> ​	在Laravel的blade模板中对{ {变量名} }内容不能直接使用HTML代码注释语法，否则还会自动解析

视图代码如下图所示：

![1545986700039](1545986700039.png)

效果如下图所示：

![1545986714024](1545986714024.png)

![1545986759936](1545986759936.png)

## 4、循环语句

```PHP
语法：
    @foreach($data as $key => $value)
    	//循环体的内容
    @endforeach
```

举例说明：

PHP代码如下图所示：

![1545987380522](1545987380522.png)

视图代码如下图所示：

![1545987418289](1545987418289.png)

路由代码如下所示：

![1545987451337](1545987451337.png)

效果如下图所示：

![1545987460394](1545987460394.png)

## 5、判断语句

### 5.1 单分支判断

```PHP
语法：
    @if(条件表达式)
    	//输出的内容
    @endif
```

举例说明：

视图代码如下图所示：

![1545987603461](1545987603461.png)

效果如下图所示：

![1545987617344](1545987617344.png)

### 5.2 多分支判断

```PHP
语法：
    @if(条件表达式1)
    	//内容1
    @elseif(条件表达式2)
    	//内容2
    @elseif(条件表达式n)
    	//内容n
    @endif
```

举例说明：

PHP代码如下图所示：

![1545988050199](1545988050199.png)

视图代码如下图所示：

![1545988077303](1545988077303.png)

效果如下图所示：

![1545988086949](1545988086949.png)

## 6、原样输出

```PHP
语法：@{ { 变量名 } }
```

> 注意：
>
> ​	在双大括号前面加上@符号，是告诉blade模板不做任何解析，直接输出该内容即可

视图代码如下图所示：

![1545988205972](1545988205972.png)

效果如下图所示：

![1545988224899](1545988224899.png)

## 7、默认值

```PHP
语法：{ { 变量名 or 默认内容 } }
```

> 注意：
>
> ​	默认值只对未定义的变量生效。

视图代码如下图所示：

![1545988466025](1545988466025.png)

效果如下图所示：

![1545988480515](1545988480515.png)

# 四、模板

```HTML
很多时候，项目的视图的头部、脚部、购物车弹窗、QQ客服、广告窗口一般都是多个页面共用，所以我们以往都是直接使用require或include来实现，后面学习ThinkPHP以后使用了layout布局，Laravel也有视图的分离技术。
```

## 1、模板分离

```
blade模板引擎里面提供了@include标签，专门给我们用于分离视图。
语法：
	@include('目录.视图名称');
参数说明：
	视图地址，基于resources/views目录开始
```

### 1.1 举例说明

PHP代码如下图所示：

![1546134048388](1546134048388.png)

视图代码如下图所示：

![1546134077636](1546134077636.png)

![1546134106595](1546134106595.png)

![1546134130981](1546134130981.png)

定义路由：

![1546134157913](1546134157913.png)

效果如下图所示：

![1546134168505](1546134168505.png)

## 2、模板继承

```
在Laravel中，blade模板引擎提供了一种模板继承的视图分离技术，这种技术的原理其实本质上来说，就是把公共代码集中到一个公共的父级视图中，然后在页面的子视图中使用@extends标签，把公共父级视图的代码继承过来使用。
子视图可以通过@yield和@section-@endsection对父级视图中的指定区域进行修改。
我们继承了公共父级视图后，还可以在子视图中对父级视图的某部分进行修改或替换。
```

> 使用模板继承有以下标签使用：
>
> @yield('区块名称')
>
> ​	在父级视图中，声明允许子视图可以新增的区域
>
> @extends('目录.模板名称')
>
> ​	在子视图中声明要继承父级视图
>
> @section('区块名称')
>
> @endsection
>
> ​	在子视图中，对父级视图中，同名的@yield区块进行新增

### 2.1、举例说明

PHP代码如下图所示：

![1546136282294](1546136282294.png)

视图代码如下图所示：

![1546136315232](1546136315232.png)

![1546136352714](1546136352714.png)

定义路由代码如下图所示：

![1546136390346](1546136390346.png)

效果如下图所示：

![1546136398725](1546136398725.png)

# 五、HTTP的请求和响应操作

## 1、请求操作

```
在Laravel中，我们接收用户发送过来的数据或请求，这块内容都是被归纳到HTTP请求操作中。
在Laravel中，处理用户请求操作的内容，都可以使用Request类处理。
```

### 1.1、案例

#### 创建一个Index控制器

![1546136656861](1546136656861.png)

#### 视图代码

![1546136818188](1546136818188.png)

#### 控制器代码

显示表单代码如下所示：

![1546138559500](1546138559500.png)

接收表单数据代码如下：

![1546138715378](1546138715378.png)

#### 定义路由

![1546138518050](1546138518050.png)

#### 效果如下

![1546138484694](1546138484694.png)

## 2、响应操作

> Laravel框架中对于用户的响应操作分两种，分别是**内容响应操作Response**和**页面跳转响应操作Redirect**

### 2.1、内容响应操作

#### 2.1.1、响应主体内容使用setContent

##### 控制器代码

![1546139723751](1546139723751.png)

##### 定义路由

![1546139748532](1546139748532.png)

##### 效果

![1546139698267](1546139698267.png)

> 注意：
>
> ​	在Laravel框架中，return的时候，会自动帮我们把复合类型的数据转成了json格式。

#### 2.1.2、返回自定义格式的内容使用header

#####  控制器代码

![1546140186281](1546140186281.png)

##### 定义路由

![1546140213237](1546140213237.png)

##### 效果

![1546140227798](1546140227798.png)

> ==注意：==
>
> ​	如果需要使用 response这个类时，一定要引入 `use Illuminate\Http\Response;` 

### 2.2、响应跳转

> 在Laravel框架中，页面跳转属于Http响应操作的一部分，由专门的Redirect类来完成这个操作。

#### 2.2.1、$redirect->to()

> 跳转到指定地址，可以跳转到外网，也可以指定对应的路由规则中

##### 控制器代码

![1546141184027](1546141184027.png)

##### 定义路由

![1546141210502](1546141210502.png)

> ==注意：==
>
> ​	==如果使用重定向类必须先引入它的命名空间：use Illuminate\Routing\Redirector;==

# 六、会话控制

## 1、cookie操作

### 控制器代码

![1546141893156](1546141893156.png)

### 定义路由

![1546141921848](1546141921848.png)

### 效果

![1546141932306](1546141932306.png)

> 注意：
>
> ​	在Laravel框架中要获取cookie要使用Request请求操作类来获取。
>
> 语法：
>
> ​	$request->cookie();	//获取全部cookie
>
> ​	$request->cookie('变量名');	//获取某一个指定的cookie信息
>
> ​	在Laravel框架中，要设置cookie要使用Response响应操作类来设置。
>
> 语法：
>
> ​	$response->cookie($name, $value, $minutes,...);
>
> 参数说明：
>
> ​	$name	[字符串]，变量名
>
> ​	$value	[字符串]，变量值
>
> ​	$minutes	[数值]，生命周期，单位是分钟

## 2、session操作

> Laravel中的session和PHP原生的是不一样的，Laravel中的session是根据PHP的原生session自己实现的一套机制。
>
> Laravel中的session有两种：
>
> 普通session：这种session的操作的使用类似于PHP原生的session。
>
> 一次性session：这种session只可以提取一次数据，在下一个页就会被Laravel销毁掉。适用于在不同页面中传递数据【错误信息，页面提示】。
>
> session类文件：vendor\laravel\framework\src\Illuminate\Session\Store.php
>
> 关于session的常用操作方法：
>
> put	存储一个session数据
>
> get	获取一个session数据
>
> flush	清空session
>
> forget	移除session

### 2.1、普通session

#### 控制器代码

##### 设置session

![1546152509713](1546152509713.png)

##### 获取session

![1546152533540](1546152533540.png)

##### 删除session

![1546152553227](1546152553227.png)

> 注意：
>
> ​	在项目开发中一般不会使用flush方法，会经常用使用forget方法。

#### 定义路由

![1546152579977](1546152579977.png)

#### 效果

![1546152595407](1546152595407.png)

### 2.2、一次性session

> 作用：一般使用在表单数据提交失败以后，返回上一页的操作中。

#### 控制器代码

![1546153693329](1546153693329.png)

#### 定义路由

![1546153727335](1546153727335.png)

#### 效果

![1546153735929](1546153735929.png)

### 2.3、一次性session的另一种设置方式

> 当用户提交的数据太多的时候，使用上面的$request->session()->flash()一个个保存会很浪费效率，所以Laravel提供了一个$request->flash()方法，专门给我们用来保存用户提交的数据到一次性session中。

#### 控制器代码

![1546153829604](1546153829604.png)

#### 视图

![1546153903173](1546153903173.png)

#### 定义路由

![1546153764579](1546153764579.png)

#### 效果

![1546153918432](1546153918432.png)

# 七、数据库操作

> Laravel框架的数据库配置文件在config/database.php，但是这个文件建议项目上时才进行使用，而在本地开发的时候，一般修改项目根目录下的（.env）文件。

## 1、新建数据库

![1546154088834](1546154088834.png)

## 2、新建数据表

```sql
为了方便演示，我们这里新增一个member数据表，创建一些测试数据。
CREATE TABLE `user` (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `username` varchar(150) NOT NULL COMMENT '用户名',
  `nickname` varchar(255) NOT NULL COMMENT '昵称',
  `password` varchar(255) NOT NULL COMMENT '密码',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
```

![1546154199249](1546154199249.png)

## 3、配置数据库

![1546154634170](1546154634170.png)

![1546154602587](1546154602587.png)

> 注意：
>
> ​	如果是使用php artisan serve指令运行着项目，修改项目的配置文件后必须得重启项目，执行ctrl+c键终止项目运行后，再次执行php artisan serve指令运行项目；配置信息才生效。

## 4、数据库操作

> Laravel的数据库操作提供三种操作：
>
> 1. 原生SQL查询，其实就是使用PHP的PDO类操作
>
> 2. DB查询构造器，其实就是ThinkPHP里面的数据库的连贯操作
>
> 3. Eloquent ORM模型，其实就是ThinkPHP里面的模型类操作

### 4.1、原生SQL查询

> Laravel框架的执行原生SQL语句就是对PHP的PDO预处理进行了一次封装。
>
> 要使用Laravel框架执行原生SQL查询，必须在控制器引入数据库扣作类DB。
>
> use Illuminate\Support\Facades\DB; 等同于 use DB;
>
> DB类对于执行原生SQL语句提供了5个方法：
>
> DB::select();	查询数据
>
> DB::insert();	添加数据
>
> DB::update();	更新数据
>
> DB::delete();	删除数据
>
> DB::statement();	执行除了增删查改以外的SQL语句

### 4.1.1、添加数据

#### 控制器代码

![1546155438897](1546155438897.png)

![1546156002538](1546156002538.png)

#### 定义路由

![1546155945804](1546155945804.png)

#### 效果

![1546155901391](1546155901391.png)

![1546155918126](1546155918126.png)

有可能报以下错误：

![1546155868034](1546155868034.png)

### 4.1.2、查询数据

#### 控制器代码

![1546156249555](1546156249555.png)

#### 定义路由

![1546156222441](1546156222441.png)

#### 效果

![1546156197059](1546156197059.png)

#### 作业：根据条件查询

### 4.1.3、更新数据

#### 控制器代码

![1546156557349](1546156557349.png)

#### 定义路由

![1546156526483](1546156526483.png)

#### 效果

![1546156503275](1546156503275.png)

### 4.1.4、删除数据

#### 控制器代码

![1546156724705](1546156724705.png)

#### 定义路由

![1546156800188](1546156800188.png)

#### 效果

![1546156776989](1546156776989.png)

# 八、DB查询构造器

> 在Laravel框架中，最常用的数据库操作方式就是DB查询构造器。
>
> 操作DB查询构造器，也是通过use Illuminate\Support\Facades\DB;类来操作。等同于 use DB;

## 1、添加数据

### 1.1、添加单条数据

#### 控制器代码

![1546157376492](1546157376492.png)

#### 定义路由

![1546157339663](1546157339663.png)

#### 效果

![1546157312680](1546157312680.png)

### 1.2、批量添加

#### 控制器代码

![1546157601208](1546157601208.png)

#### 定义路由

![1546157691973](1546157691973.png)

#### 效果

![1546157649574](1546157649574.png)

![1546157672136](1546157672136.png)

## 2、查询数据

### 2.1、查询全部数据

#### 控制器代码

![1546157971425](1546157971425.png)

#### 定义路由

![1546157939680](1546157939680.png)

#### 效果

![1546157914918](1546157914918.png)

### 2.2、查询一条数据(first)

#### 控制器代码

![1546158073492](1546158073492.png)

#### 定义路由

![1546158202003](1546158202003.png)

#### 效果

![1546158179897](1546158179897.png)

### 2.3、根据ID查询

#### 控制器代码

![1546158467081](1546158467081.png)

#### 定义路由

![1546158438908](1546158438908.png)

#### 效果

![1546158407900](1546158407900.png)

### 2.4、返回指定的字段

#### 控制器代码

![1546159558794](1546159558794.png)

#### 定义路由

![1546159596607](1546159596607.png)

#### 效果

![1546159571509](1546159571509.png)

## 3、更新数据

### 控制器代码

![1546159756465](1546159756465.png)

### 定义路由

![1546159802185](1546159802185.png)

### 效果

![1546159844543](1546159844543.png)

![1546159833406](1546159833406.png)

## 4、删除数据

### 控制器代码

![1546160194260](1546160194260.png)

### 定义路由

![1546160166725](1546160166725.png)

### 效果

![1546160120673](1546160120673.png)

## 5、连表查询

> DB查询构造器提供了join方法给我们实现连表查询
>
> 为了方便演示，我们新建一个会员评论表

```sql
create table `comment` (
id int unsigned not null auto_increment primary key comment '主键ID',
uid int unsigned not null comment '会员ID',
created_at timestamp comment '评论时间',
content text comment '评论内容'
) engine=InnoDB;

insert into `comment` (uid,created_at,content) values 
('1','2018-10-07 11:22:00','说的很有道理！！！'),
('1','2018-10-07 11:22:01','说的很有道理！！！'),
('2','2018-10-07 11:22:02','说的很有道理！！！'),
('2','2018-10-07 11:22:33','说的很有道理！！！'),
('3','2018-10-07 11:22:34','说的很有道理！！！'),
('3','2018-10-07 11:22:36','说的很有道理！！！'),
('3','2018-10-07 11:30:33','说的很有道理！！！'),
('3','2018-10-07 11:30:55','说的很有道理！！！');
```

使用DB查询构造器查询对应用户的评论数据，例如：nickname为“李四”的会员的评论

### 控制器代码

![1546160652276](1546160652276.png)

### 定义路由

![1546160604567](1546160604567.png)

### 效果

![1546160567059](1546160567059.png)

# 八、总结

**视图/模板**

​	2种

​	普通模板：后缀为.php

​	blade模板：后缀.blade.php

**分配变量有几种方式？**

​	2种

​	可能通过view()方法第二个参数传参

​	with()方法

**Laravel注释方法**

​	{ {-- 注释内容 --} }

**输出html代码，不想转义采用什么方法？**

​	{!! 输出html内容，并不转义 !!}

**遍历输出内容：**

​	@foreach()

​	......

​	@endforeach

**条件判断**

​	@if(条件表达式)

​	@endif

​	@if(条件表达式1)

​		条件表达式1的内容

​	@elseif(条件表达式2)

​		条件表达式2的内容

​	@else

​		else的内容

​	@endif

**默认值**

​	{ { 变量名 or '默认值' } }

**原样输出**

​	@{ { [变量名] } }

**视图分离**

​	2种，include 、模板继承

**HTTP请求与响应操作**

Request类操作HTTP请求

​	判断是否为post

​		$request->isMethod('post');

​	判断是否为ajax请求

​		$request->ajax();

​	获取当前URL地址

​		$request->url();

​	获取当前URI地址

​		$request->path();

​	获取当前服务器的信息

​		$request->server();

​	获取当前请求的端口

​		$request->port();

**响应操作**

​	跳转：return redirect('目标地址')

​	return redirect()->to('目标地址');

​	返回上一个请求页面

​	return redirect()->back();

**会话操作**

​	cookie

​		注意：设置cookie一定要使用Response

​		$response->cookie('键','值',['过期时间'])

​		获取

​		$request->cookie();	//获取所有

​		$request->cookie('键'); //获取指定的cookie

​		$response->cookie('键', '');  //删除cookie

​	session

​		$requset->session()->put('键', '值');	//设置session

​		$requset->session()->get();		//获取所有

​		$requset->session()->get('键');	//获取指定值

​		$requset->forget('键');	//删除指定session

​	一次session

​		$requset->session()->flash('键','值');	//设置单个一次性设置

​		$requset->flash();		//批量设置一次session

​		模板中怎么获取批量设置的一次性session：{ { old('键') } }

**DB操作原生SQL**

​	//查询

​	DB::select($sql)

​	//添加

​	例如：$sql =  "inset into user(username,password) values(:username, :password)";

​	$data = [

​		'username'=>'php32',

​		'password'=>md5('123456')

​	];

​       DB::insert($sql, $data)

​	//更新

​	例如：$sql = "update user set username=:username where id=:id";

​	$data = [

​		'id'=>1,

​		'username'=>'php34'

​	];

​	DB::update($sql, $data);

​	//删除

​	例如：$sql = "delete from user where id=:id";

​	$data = [ 'id'=>1 ];

​	DB::delete($sql,$data);

**DB查询构造器**

​	DB::table('表名')

​	//添加

​	DB::table('user')->insert( [....] ); //批量添加

​	DB::table('user')->insertGetId( [....] ); //添加一条数据

​	//查询

​	DB::table('user')->get();	//获取所有

​	DB::table('user')->first();	//获取一条

​	DB::table('user')->find(1);	//根据ID值查询，注意：主键名称一定为id

​	//更新

​	DB::table('user')->where('id', '=', 1)->update( [......] );

​	//删除

​	DB::table('user')->delete(1);

​	DB::table('user')->where('id', '=', 1)->delete();



==注意：不管使用DB操作原生SQL，还是执行DB查询构造器都必须引入DB类，use DB;==

